Brebu Costin Bogdan 321CD

Am folosit aceleasi fisiere de input pentru toti cei trei algoritmi.

Fisierele de input

test 0:
vectorul are elemente alese la intamplare si contine un numar 
mult mai mic de intervale testate decat numarul de elemente din vector.

test 1:
vectorul are elemente alese la intamplare si contine un numar 
egal de intervale testate cu numarul de elemente din vector.

test 2:
vectorul are elemente alese la intamplare si contine un numar 
mult mai mare de intervale testate decat numarul de elemente din vector.

test 3:
vectorul are elemente in ordine crescatoare si contine un numar 
mult mai mic de intervale testate decat numarul de elemente din vector.

test 4:
vectorul are elemente in ordine crescatoare si contine un numar 
egal de intervale testate cu numarul de elemente din vector.

test 5:
vectorul are elemente in ordine crescatoare si contine un numar 
mult mai mare de intervale testate decat numarul de elemente din vector.

test 6:
vectorul are elemente in ordine descrescatoare si contine un numar 
mult mai mic de intervale testate decat numarul de elemente din vector.

test 7:
vectorul are elemente in ordine descrescatoare si contine un numar 
egal de intervale testate cu numarul de elemente din vector.

test 8:
vectorul are elemente in ordine descrescatoare si contine un numar 
mult mai mare de intervale testate decat numarul de elemente din vector.

Outputurile au fost salvate separat in folderul "out"

Folosirea makefileului:

-Pentru compilarea si executarea algo1.cpp:
	make build1
	make run1

-Pentru compilarea si executarea algo2.cpp:
	make build2
	make run2

-Pentru compilarea si executarea algo3.cpp:
	make build3
	make run3

Surse de documentare:

Pentru Sparse Table:
https://www.geeksforgeeks.org/range-minimum-query-for-static-array/

Pentru Segment Tree:
https://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/

Pentru Square Root Decomposition:
https://www.geeksforgeeks.org/sqrt-square-root-decomposition-technique-set-1-introduction/




